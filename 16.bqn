âŸ¨Int, _splitâŸ© â† â€¢Import "util.bqn"
âŸ¨HashmapâŸ© â† â€¢Import "../bqn-libs/hashmap.bqn"
Combinations â† âˆ¾Â·(â‰âˆ¾Ë˜Â¨âŸœ(âˆ¾Ëœ`)ËËœâ‰ â†‘(â†“â‰â†•0)Ë™)âŒ¾âŒ½â†•âŸœâ†• # from bqncrate

words â† ' 'âŠ¸= _splitÂ¨ â€¢file.Lines "16.test"
valves â† 1 âŠ‘Â¨ words
flows â† (Int âŠ¢ /Ëœ ('0'+â†•10) âˆŠËœ âŠ¢ )Â¨ 4 âŠ‘Â¨ words
outputs â† 2 â†‘Â¨Â¨ 9 â†“Â¨ words
adj â† > valves âˆŠâš‡2 outputs
MMul â† 1 âŒŠ âŠ£ +Ëâˆ˜Ã— â‰ 1â€¿âˆ âŠ¢
nzf â† / 0 < flows
dist â† âŠ‘âˆ˜/â‰1 â‰> (<(1Â¨âŒ¾(0â€¿0â‰âŠ¢) â‰¢â¥Š0Ë™) adj) âˆ¾ MMulâŸ(â†•30)Ëœ 1Â¨âŒ¾(0â€¿0 â‰ âŠ¢) adj

cache â† HashmapËœ âŸ¨âŸ©

Step â† { # remâ€¿openâ€¿pos â† ğ•©
 0â‰¥âŠ‘ğ•© ? 0 ;
 cache.Has ğ•© ? cache.Get ğ•© ;
 open â† +Â´ flows Ã— 1 âŠ‘ ğ•©
 trees â† Moves ğ•©
 wait â† open Ã— (âŠ‘ğ•©) - âŠ‘Â¨ trees
 score â† ((âŠ‘ğ•©) Ã— open) âŒˆÂ´ wait + ğ•ŠÂ¨ trees
 ğ•© cache.Set score
 score
}

Moves â† { ğ•Š remâ€¿openâ€¿pos:
 good â† (pos â‰  âŠ¢)âŠ¸/ nzf
 t â† good âŠ pos âŠ dist
 good â†© (tâ‰¤rem) / good
 t â†© (tâ‰¤rem) / t
 tunnels â† t { tğ•Šp: âŸ¨rem - t, open, p âŸ©}Â¨ good
 { pos âŠ‘ open ? tunnels ; tunnels âˆ¾ <âŸ¨ rem - 1, 1âŒ¾(pos âŠ‘ âŠ¢) open, pos âŸ© } 
}

Elephant â† { ğ•Šğ•©:
 0 â‰¥ âŠ‘ğ•© ? 0 ;
 cache.Has ğ•© ? cache.Get ğ•© ;
 open â† +Â´ flows Ã— 1 âŠ‘ ğ•©
 âŸ¨t, open, positionsâŸ© â† ğ•©
 # todo
}

p1 â† Step âŸ¨30, 0Â¨ valves, âŠ‘/ (<"AA") â· valvesâŸ©
#p2 â† Elephant âŸ¨30, 0Â¨ valves, 2 â¥Š âŠ‘/ (<"AA") â· valvesâŸ©
